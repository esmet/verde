#define _GNU_SOURCE

#include <assert.h>
#include <event2/event.h>
#include <evhttp.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <zookeeper/zookeeper.h>

#include "verde/verde.h"

struct verde {
	zhandle_t *zh;
	struct event_base *event_base;
	struct String_vector peers;
};

#define VERDE_DISCOVERY_ROOT "/discovery/verde"

static void
verde_peers_free(struct verde *verde)
{

	for (int i = 0; i < verde->peers.count; i++) {
		free(verde->peers.data[i]);
		verde->peers.data[i] = NULL;
	}

	free(verde->peers.data);

	return;
}

static void
get_peers_cb(int rc, const struct String_vector *strings, const void *data)
{
	struct verde *verde;

	if (rc != ZOK) {
		syslog(LOG_ERR, "%s: got error %d (%s)", __FUNCTION__, rc, zerror(rc));
		return;
	}

	verde = (struct verde *)data;

	/* Forget about the old peer list */
	verde_peers_free(verde);
	verde->peers.count = strings->count;
	verde->peers.data = calloc(verde->peers.count, sizeof(char *));

	/* Save the new peer list */
	for (int i = 0; i < strings->count; i++) {
		verde->peers.data[i] = strdup(strings->data[i]);
	}

	return;
}

static void
verde_reload_peers_async(struct verde *verde)
{
	int r;
	const int watch = 1;

	r = zoo_aget_children(verde->zh, VERDE_DISCOVERY_ROOT, watch, get_peers_cb, verde);
	if (r != 0) {
		syslog(LOG_ERR, "Failed to get peers, error %d (%s)", r, zerror(r));
	}

	return;
}

static bool
starts_with(const char *path, const char prefix[])
{

	return strncmp(path, prefix, sizeof(prefix) - 1) == 0;
}

static void
verde_peer_discovery_watcher(zhandle_t *zh, int type, int state, const char *path, void *ctx)
{
	struct verde *verde;

	verde = (struct verde *)ctx;

	syslog(LOG_DEBUG, "%s: called on path %s\n", __FUNCTION__, path);

	if (state != ZOO_CONNECTED_STATE) {
		syslog(LOG_CRIT, "ZK disconnected! TODO: Handle this.");
		return;
	}

	if (starts_with(path, VERDE_DISCOVERY_ROOT) == false) {
		syslog(LOG_DEBUG, "Something uninteresting changed (%s), ignoring", path);
		return;
	}

	if (type == ZOO_CREATED_EVENT) {
		/**
		 * This is only generated by watches on non-existent nodes. These watches
		 * are set using \ref zoo_exists.
		 */
		syslog(LOG_DEBUG, "Got created event");
	} else if (type == ZOO_DELETED_EVENT) {

		/**
		 * This is only generated by watches on nodes. These watches
		 * are set using \ref zoo_exists and \ref zoo_get.
		*/
		syslog(LOG_DEBUG, "Got deleted event");
	} else if (type == ZOO_CHANGED_EVENT) {

		/**
		 * This is only generated by watches on nodes. These watches
		 * are set using \ref zoo_exists and \ref zoo_get.
		 */
		syslog(LOG_DEBUG, "Got changed event");
	} else if (type == ZOO_CHILD_EVENT) {

		/**
		 * This is only generated by watches on the child list of a node. These watches
		 * are set using \ref zoo_get_children or \ref zoo_get_children2.
		 */
		syslog(LOG_DEBUG, "Got child event");
	} else if (type == ZOO_SESSION_EVENT) {
		/**
		 * This is generated when a client loses contact or reconnects with a server.
		 */
		syslog(LOG_DEBUG, "Got session event");
	} else if (type == ZOO_NOTWATCHING_EVENT) {

		/**
		 * This is generated when the server for some reason, probably a resource
		 * constraint, will no longer watch a node for a client.
		 */
		syslog(LOG_DEBUG, "Got notwatching event");
	} else {
		syslog(LOG_DEBUG, "Some unknown action type occurred");
	}

	assert(zh == verde->zh);
	verde_reload_peers_async(verde);

	return;
}

static void
verde_log_peers(struct verde *verde)
{

	syslog(LOG_INFO, "peers: (%d)", verde->peers.count);
	for (int i = 0; i < verde->peers.count; i++) {
		syslog(LOG_INFO, "  %s", verde->peers.data[i]);
	}
	syslog(LOG_INFO, "%s", "");

	return;
}

static void
verde_log_peers_event(int fd, short what, void *arg)
{
	struct verde *verde;

	(void) fd;
	(void) what;
	verde = (struct verde *)arg;
	verde_log_peers(verde);

	return;
}

static void
verde_register_self(struct verde *verde)
{
	int r;
	char *path;

	asprintf(&path, "%s/verde.%d", VERDE_DISCOVERY_ROOT, getpid());
	r = zoo_create(verde->zh, path,
	    /* No actual data will be stored in this node. */
	    NULL, 0,
	    /* No safety yet. */
	    &ZOO_OPEN_ACL_UNSAFE,
	    /* We use an ephemeral node so that if we crash or don't clean up, ZK will. */
	    ZOO_EPHEMERAL,
	    /* No output path. */
	    NULL, 0);
	if ((r == ZOK || r == ZNODEEXISTS) == false) {
		syslog(LOG_ERR, "During registrion, got unknown error %d (%s) from zoo_create.",
		    r, zerror(r));
	}

	free(path);

	return;
}

static void
verde_register_self_event(int fd, short what, void *arg)
{
	struct verde *verde;

	(void) fd;
	(void) what;
	verde = (struct verde *)arg;
	verde_register_self(verde);

	return;
}

int
verde_create(struct verde **verde_p)
{
	struct verde *verde;
	struct event *ev;
	const struct timeval refresh_interval = { .tv_sec = 5, .tv_usec = 0 };

	verde = calloc(1, sizeof(struct verde));
	*verde_p = NULL;
	
	verde->zh = zookeeper_init("localhost:2181", verde_peer_discovery_watcher,
	    /* Timeout, client id, context, and flags */
	    10 * 1000, NULL, verde, 0);
	if (verde->zh == NULL) {
		syslog(LOG_ERR, "Couldn't connect to zookeeper.");
		goto error;
	}

	syslog(LOG_INFO, "Ensuring service discovery path exists (%s)", VERDE_DISCOVERY_ROOT);
	const int r = zoo_create(verde->zh, VERDE_DISCOVERY_ROOT,
	    /* No actual data will be stored in this node. */
	    NULL, 0,
	    /* No safety yet. */
	    &ZOO_OPEN_ACL_UNSAFE,
	    /* Normal node. No special flags. */
	    0,
	    /* No output path. */
	    NULL, 0);
	if ((r == ZOK || r == ZNODEEXISTS) == false) {
		syslog(LOG_ERR, "During setup, got unknown error %d (%s) from zoo_create.",
		    r, zerror(r));
		goto error;
	}

	verde->event_base = event_base_new();
	assert(verde->event_base != NULL);

	/* Periodically ensure that this instance is registered with ZK */
	verde_register_self(verde);
	ev = event_new(verde->event_base, -1, EV_PERSIST, verde_register_self_event, verde);
	event_add(ev, &refresh_interval);

	/* Now that we have registered, load the full set of peers. This read
	 * will setup a watch on VERDE_DISCOVERY_ROOT for new child nodes. */
	verde_reload_peers_async(verde);

	/* Periodically dump the list of peers */
	verde_log_peers(verde);
	ev = event_new(verde->event_base, -1, EV_PERSIST, verde_log_peers_event, verde);
	event_add(ev, &refresh_interval);

	*verde_p = verde;
	return 0;
error:

	verde_destroy(verde_p);
	return -1;
}

void
verde_destroy(struct verde **verde_p)
{
	struct verde *verde;

	verde = *verde_p;
	verde_peers_free(verde);

	if (verde->zh != NULL) {
		zookeeper_close(verde->zh);
	}

	if (verde->event_base != NULL){
		event_base_free(verde->event_base);
	}

	memset(verde_p, 0, sizeof(*verde_p));
	free(verde_p);

	return;
}

void
verde_dispatch(struct verde *verde)
{

	event_base_dispatch(verde->event_base);

	return;
}
